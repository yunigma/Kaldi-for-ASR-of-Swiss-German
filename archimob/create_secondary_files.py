#!/usr/bin/python

"""
Using as input a csv file (v.gr, created with process_exmaralda_xml.py), or a
scp transcriptions file (in lines, utt_id transcription), this script generates
some files that are needed to train acoustic models or decode waveforms with
Kaldi:
- wav.scp: file with mappings from utterance ids to wave locations
- spk2utt: file with mappings from speaker ids to utterance ids
- utt2spk: file with mappings from utterance ids to speaker ids
"""

import sys
import os

import argparse
import csv

from shutil import copyfile

# Extension for the wavefiles:
WAV_EXTENSION = 'wav'


def get_args():
    """
    Returns the command line arguments
    """

    my_desc = 'Program that creates the files wav.scp, spk2utt, and utt2spk, ' \
              'either for training acoustic models or for decoding. In the ' \
              'first case, the input is a csv file and a wavelist with the ' \
              'utterances chosen for training (typically used after ' \
              'process_archimob_csv.py). In the second case, the input is a ' \
              'text file with utterance ids in the first column, and the ' \
              'reference transcriptions in the second (for WER computation)'

    parser = argparse.ArgumentParser(description=my_desc)


    input_mode_parser = parser.add_subparsers(help='Train or Decode or Test')

    parser_train = input_mode_parser.add_parser('train', help='The target is ' \
                                                'to train acoustic models. ' \
                                                'The input is a csv file and ' \
                                                'a list with the utterances ' \
                                                'chosen for training')

    parser_train.add_argument('--input-csv', '-i', help='Input csv file',
                              required=True)

    parser_train.add_argument('--input-list', '-l', help='Input wave list',
                              required=True)

    parser_decode = input_mode_parser.add_parser('decode', help='The target ' \
                                                 'is to decode wavefiles. The' \
                                                 ' input is a file with the ' \
                                                 'reference transcriptions ' \
                                                 '(in lines, utt_id ' \
                                                 'transcription)')

    parser_test = input_mode_parser.add_parser('test', help='The target ' \
                                               'is to evaluate test wavefiles.' \
                                               'The input is a wav dir.')

    parser_decode.add_argument('--input-transcriptions', '-t', help='File ' \
                               'with the references for decoding',
                               required=True)

    parser.add_argument('--input-wav', '-w', help='Folder with the wavefiles ' \
                        'corresponding to the wave list. Note that the ' \
                        'extension {0} is assumed'.format(WAV_EXTENSION),
                        required=True)

    parser.add_argument('--output-dir', '-o', help='Name of the output folder',
                        required=True)

    return parser.parse_args()


def read_set(input_file):
    """
    Reads a file, returning its lines in a set
    input:
        * input_file (str): name of the input file
    returns:
        * a set with the content of the file
    """

    output = set()

    try:
        input_f = open(input_file, 'r')
    except IOError as err:
        sys.stderr.write('Error reading {0} ({1})\n'.format(input_file, err))
        sys.exit(1)

    for utt_id in input_f:

        output.add(utt_id.decode('utf8').rstrip())

    input_f.close()

    return output


def process_csv(input_csv, input_list, wav_dir, output_w, output_u):
    """
    Writes the content of the wav scp and utt2spk files, taking as input a
    csv file and a file with the list of chosen utterances. This is the
    typical configuration for acoustic model training
    input:
        * input_csv (str): name of the input csv file (as generated by
          process_exmaralda.py)
        * input_list (str): list of chosen utterances. It does not need to be
          all the ones from the csv file, given that some of them might have
          been rejected with process_archimob_csv.py.
        * wav_dir (str): absolute path of the folder with the wavefiles
        * output_w (file object): file object to write the wav scp content
        * output_u (file object): file object to write the utterance to
          speaker ids mappings
    returns:
        * a dictionary with the speaker to lists of utterance ids mappings
    """

    spk2utt = {}

    # Read the input wave list:
    wav_set = read_set(input_list)

    # Open the input csv:
    try:
        input_f = open(input_csv, 'r')
    except IOError as err:
        sys.stderr.write('Error opening {0} ({1})\n'.format(input_csv, err))
        sys.exit(1)

    csv_reader = csv.reader(input_f)

    for index, row in enumerate(csv_reader):

        if index == 0:
            header = row
            header_size = len(row)
            continue

        if len(row) != header_size:
            sys.stderr.write('Error reading {0}: different number of elements' \
                             ' in header ({1}), and line {2} ' \
                             '({3})\n'.format(input_csv, header_size,
                                              index, len(row)))
            sys.exit(1)

        data = {key: value.decode('utf8') for key, value in zip(header, row)}

        # Extract the meaningful columns:
        utt_id = data['utt_id'].split(".")[0]
        spk_id = data['speaker_id']

        # Check whether this utterance was chosen in process_archimob.csv:
        if utt_id not in wav_set:
            continue

        # Write the entry in wav.scp:
        wav_name = os.path.join(wav_dir, utt_id.encode('utf8'))
        # output_w.write('{0} sox {1} -r 16000 -t wav - |\n'.format(utt_id.encode('utf8'),
        #                                                             wav_name))
        output_w.write('{0} ' \
                       '{1}.{2}\n'.format(utt_id.encode('utf8'),
                                          wav_name, WAV_EXTENSION))

        # Write the entry in utt2spk:
        output_u.write('{0} {1}\n'.format(utt_id.encode('utf8'),
                                          spk_id.encode('utf8')))

        # Add the utterance to spk2utt:
        if spk_id in spk2utt:
            spk2utt[spk_id].append(utt_id)
        else:
            spk2utt[spk_id] = [utt_id]

    input_f.close()

    return spk2utt


def process_transcriptions(input_transcriptions, wav_dir, output_w, output_u):
    """
    Writes the content of the wav scp and utt2spk files, taking as input a
    file with transcriptions, with the format "utt_id transcription", in lines.
    This is the typical configuration for decoding
    input:
        * input_transcriptions (str): name of the input file with the reference
          transcriptions
        * wav_dir (str): absolute path of the folder with the wavefiles
        * output_w (file object): file object to write the wav scp content
        * output_u (file object): file object to write the utterance to
          speaker ids mappings
    returns:
        * a dictionary with the speaker to lists of utterance ids mappings
    Note: in this case no speaker id information is available. Therefore, the
          utt2spk and spk2utt information is created mapping each file to
          itself
    """

    spk2utt = {}

    # Open the trancriptions file:
    try:
        input_f = open(input_transcriptions, 'r')
    except IOError as err:
        sys.stderr.write('Error opening {0} ' \
                         '({1})\n'.format(input_transcriptions, err))
        sys.exit(1)

    for line in input_f:

        if line.isspace():
            continue

        utt_id = line.rstrip().split()[0]

        # Write the entry in wav.scp:
        wav_name = os.path.join(wav_dir, utt_id.encode('utf8'))
        # output_w.write('{0} sox {1} -r 16000 -t wav - |\n'.format(utt_id.encode('utf8'),
        #                                                           wav_name))
        output_w.write('{0} ' \
                       '{1}.{2}\n'.format(utt_id, wav_name, WAV_EXTENSION))

        # Write the entry in utt2spk:
        output_u.write('{0} {0}\n'.format(utt_id))

        # Add the utterance to spk2utt:
        spk2utt[utt_id] = [utt_id]

    return spk2utt


def process_audio(wav_dir, output_w, output_u):
    """
    Writes the content of the wav scp and utt2spk files, taking as input a
    file with transcriptions, with the format "utt_id transcription", in lines.
    This is the typical configuration for decoding
    input:
        * wav_dir (str): absolute path of the folder with the wavefiles
        * output_w (file object): file object to write the wav scp content
        * output_u (file object): file object to write the utterance to
          speaker ids mappings
    returns:
        * a dictionary with the speaker to lists of utterance ids mappings
    Note: in this case no speaker id information is available. Therefore, the
          utt2spk and spk2utt information is created mapping each file to
          itself
    """

    spk2utt = {}

    # Open the audios file:
    for filename in sorted(os.listdir(wav_dir)):
        if not filename.startswith('.'):
            # print(filename)
            path = "{}{}".format(wav_dir, filename)

            utt_id = filename

            # Write the entry in wav.scp:
            wav_name = os.path.join(wav_dir, utt_id.encode('utf8'))
            # output_w.write('{0} sox {1} -r 16000 -t wav - |\n'.format(utt_id.encode('utf8'),
            #                                                           wav_name))
            output_w.write('{0} ' \
                           '{1}.{2}\n'.format(utt_id, wav_name, WAV_EXTENSION))

            # Write the entry in utt2spk:
            output_u.write('{0} {0}\n'.format(utt_id))

            # Add the utterance to spk2utt:
            spk2utt[utt_id] = [utt_id]

    return spk2utt


def main():
    """
    Main function of the program
    """

    # Read the command line arguments:
    args = get_args()

    # Get the absolute path for the input wavs folder:
    abs_wav_dir = os.path.abspath(args.input_wav)

    # Create the output folder:
    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)

    # Define the names of the output files:
    output_wav = os.path.join(args.output_dir, 'wav.scp')
    output_spk = os.path.join(args.output_dir, 'spk2utt')
    output_utt = os.path.join(args.output_dir, 'utt2spk')

    # Create the output files:
    try:
        output_w = open(output_wav, 'w')
    except IOError as err:
        sys.stderr.write('Error creating {0} ({1})\n'.format(output_wav, err))
        sys.exit(1)

    try:
        output_u = open(output_utt, 'w')
    except IOError as err:
        sys.stderr.write('Error creating {0} ({1})\n'.format(output_utt, err))
        sys.exit(1)

    if 'input_csv' in args:
        spk2utt = process_csv(args.input_csv, args.input_list, abs_wav_dir,
                              output_w, output_u)
    else:
        if 'input_transcriptions' in args:
            spk2utt = process_transcriptions(args.input_transcriptions,
                                             abs_wav_dir,
                                             output_w, output_u)
            # Also, copy to the output folder the transcriptions file:
            try:
                copyfile(args.input_transcriptions, os.path.join(args.output_dir,
                                                                 'text'))
            except OSError as err:
                sys.stderr.write('Error copying {0} to {1} ' \
                                 '({2})\n'.format(args.input_transcriptions,
                                                  args.output_dir, err))
                sys.exit(1)
        else:
            spk2utt = process_audio(abs_wav_dir, output_w, output_u)


    output_w.close()
    output_u.close()

    # Finally, create the spk2utt file:
    try:
        output_s = open(output_spk, 'w')
    except IOError as err:
        sys.stderr.write('Error creating {0} ({1})\n'.format(output_spk, err))
        sys.exit(1)

    for spk_id in sorted(spk2utt):
        output_s.write('{0}'.format(spk_id.encode('utf8')))

        for utt_id in sorted(spk2utt[spk_id]):
            output_s.write(' {0}'.format(utt_id.encode('utf8')))

        output_s.write('\n')

    output_s.close()


if __name__ == '__main__':
    main()
